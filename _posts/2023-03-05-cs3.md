---
layout : post
title : "정보처리기사 필기(소프트웨어 개발)"
date: '2023-03-05 15:52:00 +09:00'
categories : [Study,CS]
tags : [정보처리기사,자격증,정처기] #소문자만 가능
---


### <2과목 소프트웨어 개발>

#### 1. 자료구조

**자료 구조의 분류**

- 선형 구조(Linear Structure) : 배열, 스택, 큐,  데크, 선형 리스트

- 비선형 구조(Non-Linear Structure) : 트리, 그래프

1) **배열(Array)**

- 정적인 자료 구조로 기억장소의 추가가 어렵고 메모리의 낭비 발생

- 반복적인 데이터 처리 작업에 적합한 구조

2) **스택(Stack)**

- 입출력이 한쪽 끝으로만 제한된 리스트이다.

- 더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.

- 후입선출(LIFO, Last In First Out) 방식이다.

**스택을 이용한 연산**

- 재귀호출

- 후위표현(Post-fix expression)의 연산

- 깊이우선탐색

- ~~선택정렬~~

- 서브루틴 호출, 인터럽트 처리, 수식 계산 및 수식 표기법에 응용된다.

3) **큐(Queue)**

- 한쪽에서는 삽입 작업, 다른 한쪽에서는 삭제 작업이 이뤄진다.

- Head(front)와 Tail(rear)의 2개 포인터를 갖고 있다.

- 선입선출(FIFO, First In First Out) 방식이다.

**큐를 이용한 연산**

- 운영체제의 작업 스케줄링에 사용한다.

4) **데크(Deque)**

- 삽입과 삭제가 리스트의 양쪽 끝에서 발생할 수 있는 자료 구조이다.

- 스택과 큐의 장점으로 구성한 것이다.

- Double Ended Queue의 약자이다.

- 입력 제한 데크는 Scroll이고, 출력 제한 테크는 Shelf이다.

5) **선형 리스트(Linear List)**

- 연속 리스트(Contiguous List) => **순차적**

- 배열과 같이 연속되는 기억장소에 저장되는 자료 구조

- 기억장소를 연속적으로 배정받아, 기억장소 이용 효율은 밀도가 1로서 가장 좋음

- 중간에 데이터를 삽입하기 위해 연속된 빈 공간이 있어야함

- 삽입, 삭제 시 자료의 이동이 필요함

- 연결 리스트(Linked List) => **비순차적**

- 자료들을 반드시 연속적으로 배열시키지 않고 임의의 기억공간을 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용해 서로 연결시킨 자료 구조

- 노드의 삽입, 삭제 작업이 용이

- 기억공간이 연속적으로 놓여 있지 않아도 저장가능

- 연결을 위한 포인터가 필요하기 때문에 순차 리스트에 비해 기억 공간의 효율이 좋지 않음

- 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느림

- 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘듦

6) **트리(Tree)**

- 그래프의 특수한 형태

- 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의

관계성이 계층 형식으로 나타나는 비선형 구조

- 근 노드(Root Node) : 트리의 맨 위에 있는 노드

- 디그리(Degree, 차수) : 각 노드에서 뻗어 나온 가지의 수

- 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수

- 단말 노드(Terminal Node) : 자식이 하나도 없는 노드, Degree가 0인 노드

*다음 트리의 차수(degree)와 단말 노드(terminal node)의 수는?*
**차수: 2 (A,C,E), 단말 노드: 4 (D,G,H,F)**  
<img width="123" alt="image" src="https://user-images.githubusercontent.com/71093890/222945089-a8971e4a-ab0c-4fef-bca2-d757603e43e0.png">

*다음 트리의 차수(degree)는?*
 **3 (B)**  
<img width="141" alt="image" src="https://user-images.githubusercontent.com/71093890/222945102-91fff0b8-5721-4fe1-a7b0-cd85adf9b4cd.png">

**트리 순회방법**

- 전위 순회(Preorder Traversal) : **Root** → Left → Right

- 중위 순회(Inorder Traversal) : Left → **Root** → Right

- 후위 순회(Postorder Traversal) : Left → Right → **Root**

	*다음 트리에 대한 중위 순회 운행 결과는?*
	 **D B A E C F**  
  <img width="128" alt="image" src="https://user-images.githubusercontent.com/71093890/222945107-99d6087f-0f1d-45ab-b4fb-cd9da6f63fb9.png">

	*다음 트리를 Preorder 운행법으로 운행할 경우 다섯 번째로 탐색되는 것은?*
	 A B D C E G H F 이므로 **E**  
  <img width="109" alt="image" src="https://user-images.githubusercontent.com/71093890/222945110-9f7d85f7-bd5d-4cd2-b256-09bb3e8794b3.png">


	*다음 트리에 대한 INORDER 운행 결과는?*
	 **D B A E C F**  
  <img width="106" alt="image" src="https://user-images.githubusercontent.com/71093890/222945122-76054755-f0aa-4e0d-b4fc-3acb7337b9bb.png">

	(Preorder : A B D C E F, Postorder : D B E F C A)

	*다음 트리를 Preorder 운행법으로 운행할 경우 가장 먼저 탐색되는 것은?*
	 A B D C E G H F **이므로** **A**  
  <img width="91" alt="image" src="https://user-images.githubusercontent.com/71093890/222945128-f91a6bf9-9472-481e-a7f6-c3b0886deeb6.png">

	*다음 트리를 전위 순회(preorder traversal)한 결과는?*
	 **+ * * / A B C D E**  
  <img width="111" alt="image" src="https://user-images.githubusercontent.com/71093890/222945135-7869f052-7959-457d-b8f2-4003615759e7.png">


7) **그래프(Graph)**

**방향 그래프**

- 정점을 연결하는 선에 방향이 있는 그래프

- n개의 정점으로 구성된 방향 그래프의 최대 간선 수 = **n(n-1)**

**무방향 그래프**

- 정점을 연결하는 선에 방향이 없는 그래프

- n개의 정점으로 구성된 무방향 그래프의 최대 간선 수 = **n(n-1)/2**

***다음 그래프에서 정점 A를 선택하여 깊이우선탐색 (DFS)으로 운행한 결과는?*** 
**ABEFGCD**  
<img width="93" alt="image" src="https://user-images.githubusercontent.com/71093890/222945142-e2e5fb35-00eb-4999-b757-b61c2ddab469.png">

***제어흐름 그래프가 다음과 같을 때 McCabe의 cyclomatic 수는 얼마인가?***
**4**  
<img width="94" alt="image" src="https://user-images.githubusercontent.com/71093890/222945147-96384ad1-b36f-444c-991a-2126dc0193ff.png">
선-점+2 = 6-4+2
#### 2. 알고리즘


**이진 검색 알고리즘**

- 탐색 효율이 좋고 탐색 시간이 적게 소요된다.

- 검색할 데이터가 정렬되어 있어야 한다.

- 비교횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.

**피보나치 검색 알고리즘**

- 피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다.

**알고리즘 설계 기법**

**1)** **분할과 정복** **(Divide and Conquer)**

- 문제를 나눌 수 없을 때까지 나누고, 각각을 풀면서 다시 병합해 문제의 답을 얻음

**2)** **동적계획법** **(Dynamic Programming)**

- 어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는 방식

**3)** **탐욕법** **(Greedy)**

- 결정을 해야 할 때마다 그 순간에 가장 좋다고 생각되는 것을 해답으로 선택

- 현재 시점에서 가장 최적의 방법을 선택

**4)** **백트래킹** **(Backtracking)**

- 어떤 노드의 유망성 점검 후, 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후 다른 자손 노드를 검색

- 해를 찾는 도중 해가 아니어서 막히면, 되돌아가서 다시 해를 찾아간다.


<img width="629" alt="image" src="https://user-images.githubusercontent.com/71093890/222945339-49323842-8a7d-4939-b0ec-de22e3189b4f.png">


***최악의 경우 검색 효율이 가장 나쁜트리 구조는?***

**-** **이진 탐색트리** **=> O(n)**

- AVL 트리 => O(log n)

- 2-3 트리 => O(log 3n)

- 레드-블랙 트리 => O(log n)

### 3. 정렬알고리즘

● 삽입정렬
- 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬
*삽입 정렬(Insertion Sort)을 이용하여 오름차순 정렬할 경우 1회전 후의 결과는?*  
**3, 8, 4, 9, 7**    
 <img width="138" alt="image" src="https://user-images.githubusercontent.com/71093890/222945433-76cddb49-96b2-4a98-bb8c-52e831a30a21.png">


● 쉘 정렬
- 임의의 레코드 키와 매개변수(h)값만큼 떨어진 곳의 레코드 키를 비교하여 서로 교환해 가면서 정렬한다.
- 삽입정렬의 확장 개념. 입력파일이 부분적으로 정렬되어 있는 경우 유리한 방식.
- 입력파일을 매개변수값으로 서브파일 구성하고 각 서브파일을 삽입정렬로 순서 배열하는 과정을 반복함

● 선택정렬
- n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 n-1개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하는 정렬
*다음 자료에 대하여 “Selection Sort”를 사용하여 오름차순으로 정렬한 경우 PASS 3의 결과는?*  
**3, 4, 7, 9, 8**    
 <img width="141" alt="image" src="https://user-images.githubusercontent.com/71093890/222945421-b5b1b529-09ce-41de-9c8a-f6599f0f4ee6.png">


*다음 자료에 대하여 선택 정렬을 이용하여 오름차순으로 정렬하면 3회전 후의 결과는?*  
**14, 17, 35, 40, 37**  

 <img width="124" alt="image" src="https://user-images.githubusercontent.com/71093890/222945417-dd69bacb-e832-4b42-a005-34d21b8e0a8c.png">


● 버블정렬
- 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환한다.

*다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 Pass 2의 결과는?*  
**6, 3, 5, 7, 9**  
*다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 PASS 3의 결과는?*   
**3, 5, 6, 7, 9**    
 <img width="124" alt="image" src="https://user-images.githubusercontent.com/71093890/222945414-bb19c419-3bf2-4c77-95e1-703eb925ab69.png">


● 퀵 정렬
- 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬한다.

● 힙 정렬
- 정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키 값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬
- 평균 수행 시간은 O(nlog2n)이다.
- 완전 이진트리(complete binary tree)로 입력자료의 레코드를 구성한다.
- ~~최악의 수행 시간은 O(2n4)이다.~~

● 합병정렬
- 정렬된 N개의 데이터를 처리하는 데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘


### 4. 화이트박스, 블랙박스 테스트
- 테스트 케이스에는 일반적으로 시험 조건, 테스트 데이터, 예상 결과가 포함되어야 한다.

● 화이트박스 테스트(White Box Test)
- 화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 있다.
- 모듈 안의 작동을 직접 관찰 할 수 있다.
- 산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 
논리적 경로를 점검한다.
- Source Code의 모든 문장을 한번 이상 수행함으로서 진행된다.
- ~~기본 경로(BasisPath)란 흐름 그래프의 시작노드에서 종료노드까지의 서로 독립된 경로로 싸이클을 허용하지 않는 경로다.~~
- ~~Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.~~

*화이트박스 검사로 찾기 힘든 오류는?*
- 논리흐름도, 루프구조, 순환복잡도, 자료구조

화이트박스 검사 기법 # 기조루데
1) 기초 경로 검사(Base Path Testing) : 테스트 측정 결과는 실행 경로의 기초를 정의하는 지침으로 사용
2) 조건 검사(Condition Testing) : 논리적 조건을 테스트
3) 루프 검사(Loop Testing) : 반복 구조에 맞춰 테스트
4) 데이터 흐름 검사(Data Flow Testing) : 변수의 정의와 변수가 사용되는 위치에 초점을 맞춰 테스트

● 블랙박스(Black Box Test)
- 블랙박스 테스트는 프로그램의 구조를 고려하지 않는다.
- 모듈 안에서 어떤 일이 일어나는지 알 수 없음
- 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트(기능 테스트)
- 소프트웨어 인터페이스에서 실시되는 테스트

블랙박스 검사 기법 # 동경원비오
1) 동등 분할 검사(Equivalence Partitioning Testing), 동치 분할 검사
- 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 해 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법
2) 경계값 분석(Boundary Value Analysis)
- 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용해 입력 조건의 경계값을 테스트 케이스로 선정해 검사하는 기법
3) 원인-효과 그래프 검사(Cause-Effect Graphing Testing)
- 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정해 검사하는 기법
4) 비교 검사(Comparison Testing)
- 여러 버전의 프로그램에 동일한 테스트 자료를 제공해 동일한 결과가 출력되는지 테스트하는 기법
5) 오류 예측 검사(Error Guessing)
- 다른 블랙박스 테스트 기법으로 찾아낼 수 없는 오류를 찾아내는 일력의 보충적 검사 기법(데이터 확인 검사)

*블랙박스 테스트를 이용하여 발견할 수 있는 오류*
- 비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우
- 정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우
- 경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경우
- ~~반복 조건을 만족하는데도 루프 내의 문장이 수행되지 않는 경우~~

*평가 점수에 따른 성적부여는 다음 표와 같다. 이를 구현한 소프트웨어를 경계값 분석 기법으로 테스트 하고자 할 때 다음 중 테스트 케이스의 입력 값으로 옳지 않은 것은?*  
**59, 80, 90, 101**  
<img width="135" alt="image" src="https://user-images.githubusercontent.com/71093890/222945582-09b91a4e-6946-4cd6-8192-b8fdfb9d24ac.png">

### 5. 형상 관리

형상 관리(SCM, Software Configuration Management)
- 개발 과정의 변경 사항을 관리하는 것
- 소프트웨어에 가해지는 변경을 제어하고 관리한다.
- 소프트웨어에서 일어나는 수정이나 변경을 알아내고 제어하는 것을 의미한다.
- 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다.
- 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것이다.
- 유지 보수 단계뿐만 아니라 개발 단계에도 적용할 수 있다.
- 형상관리의 기능 중 하나는 버전 제어 기술이다.
- 프로젝트 계획, 분석서, 설계서, 프로그램, 테스트 케이스 모두 관리 대상이다.
- 형상 관리를 통해 이전 리버전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용
- 불필요한 사용자의 소스 수정 제한
- 동일한 프로젝트에 대해 여러 개발자 동시 개발 가능
- ~~프로젝트 개발비용을 효율적으로 관리~~
- ~~형상 통제 과정에서는 형상 목록의 변경 요구를 즉시 수용 및 반영해야 한다.~~
- ~~대표적인 형상관리 도구로 Ant, Maven, Gradle 등이 있다. => 빌드 자동화 도구~~
- ~~형상관리를 위하여 구성된 팀을 “chief programmer team”이라고 한다.~~

형상 관리 도구의 주요 기능
- 저장소(Repository) : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳
- 가져오기(Import) : 버전 관리가 되고 있지 않은 아무것도 없는 저장소에 처음으로 파일을 복사하는 것
- 동기화(Update) : 저장소에 있는 최신 버전으로 자신의 작업 공간(로컬 저장소)을 동기화하는 것
- 체크아웃(Check-Out) : 프로그램을 수정하기 위해 저장소에서 파일을 받아오는 것
- 체크인(Check-In) : 저장소에 새로운 버전의 파일로 갱신하는 것
- 커밋(Commit) - 체크인을 수행할 때 충돌(Confilct) 날 경우 diff도구를 이용해 수정 후 갱신 완료
- ~~정규화(Normalization)~~

형상 관리 절차 : 형상 식별 -> 형상 통제 -> 형상 감사 -> 형상 기록/보고

① 형상 식별
- 형상 관리 계획을 근거로 형상관리의 대상이 무엇인지 식별하는 과정이다.
② 형상 통제
- 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Baseline)이 잘 반영될 수 있도록 조정
- 형상 통제가 이루어지기 위해서는 형상 통제 위원회(CCB)의 승인을 통한 변경 통제가 이루어짐
③ 형상 감사
- 형상 관리 계획대로 형상관리가 진행되고 있는지, 형상 항목의 변경이 요구 사항에 맞도록 제대로
 이뤄졌는지 등을 살펴보는 활동이다.
④ 형상 기록/보고
- 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

*소프트웨어 형상 관리에서 ‘관리’ 항목에 포함되지 않는 것은?*
- 프로젝트 요구 분석서
- 소스 코드
- 운영 및 설치 지침서
- ~~프로젝트 개발 비용~~

### 6. 버전 관리

1) 공유 폴더 방식
- 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식
- 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사함
- 담당자는 공유 폴더의 파일을 자기 PC로 복사해 컴파일 한 후 이상 유무 확인
- 파일의 변경 사항을 데이터베이스에 기록하며 관리
- ex. SCCS, RCS, PVCS, QVCS

2) 클라이언트/서버 방식
- 버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리되는 방식
- 서버의 자료를 개발자별로 자신의 PC(클라이언트)로 복사해 작업한 후 변경된 내용을 중앙 서버에 반영
- 모든 버전 관리는 서버에서 수행됨
- 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력
- 서버에 문제가 생기면 다른 개발자와의 협업 및 버전 관리 작업은 중단됨
- ex. CVS, SVN(Subversion)

3) 분산 저장소 방식
- 버전관리 자료가 원격저장소와 로컬저장소에 함께 저장되어 관리된다.
- 로컬저장소에서 버전관리가 가능하므로 원격저장소에 문제가 생겨도 로컬저장소의 자료를 이용하여 작업할
 수 있다.
- 대표적인 버전 관리 도구로 Git이 있다.
- 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식
- 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사해 작업한 후 변경 된 내용을 로컬 저장소에서 우선 반영(Commit)한 다음 이를 원격 저장소에 반영(Push)
- 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용해 작업 가능
- 로컬 저장소에서 작업을 수행할 수 있어 처리속도가 빠름
- ex. Git, Bitkeeper

### 7. 테스트
애플리케이션 테스트의 기본 원칙
1) 테스팅은 결함이 존재함을 밝히는 것
- 결함을 줄일 순 있지만, 결함이 없다고는 증명할 수 없음
2) 완벽한 테스팅은 불가능
- 무한 경로, 무한 입력 값으로 인한 어려움
3) 개발 초기에 테스팅 시작
- 테스팅 기간 단축, 재작업 감소로 개발 기간 단축 및 결함 예방
4) 결함 집중
- 파레토 법칙이 좌우한다. (Pareto)
- 애플리케이션 결함의 대부분은 소수의 특정한 모듈에 집중되어 존재한다.
- 결함은 발생한 모듈에서 계속 추가로 발생할 가능성이 높다.
*Pareto의 법칙 : 소프트 웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다.*  
*Brooks의 법칙 : 지연되는 프로젝트에 인력을 더 투입하면 오히려 더 늦어진다.*  
5) 살충제 패러독스(Pesticide Paradox)
- 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함
6) 테스팅은 정황에 의존적
- 소프트웨어 성격에 맞게 테스트 실시
7) 오류-부재의 궤변
- 요구사항을 충족시켜주지 못한다면, 결함이 없어도 품질이 높다 볼 수 없음

애플리케이션 테스트의 분류
1) 프로그램 실행 여부에 따른 테스트
- 정적 테스트
- 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트
- 워크 스루, 인스펙션, 코드 검사
- 동적 테스트
- 프로그램을 실행하여 오류를 찾는 테스트
- 화이트박스 테스트, 블랙박스 테스트

2) 테스트 기반에 따른 테스트
- 명세 기반 테스트
- 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
- 동등 분할, 경계값 분석(블랙박스 테스트)
- 구조 기반 테스트
- 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
- 구문 기반, 결정 기반, 조건 기반(화이트박스 테스트)
- 경험 기반 테스트
- 테스터의 경험을 기반으로 수행하는 테스트
- 에러 추정, 체크 리스트, 탐색적 테스팅

3) 시각에 따른 테스트
- 검증(Verification) 테스트
- 개발자의 시각에서 제품의 생산 과정을 테스트하는 것
- 검증은 소프트웨어 개발 과정을 테스트하는 것이다. 작업 제품이 개발자의 기대를 충족시키는지 측정한다.
- 단위 테스트, 통합 테스트, 시스템 테스트
- 확인(Validation) 테스트
- 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것
- 확인은 소프트웨어 결과를 테스트 하는 것이다. 사용자의 요구에 적합한지 측정한다.
- 인수 테스트(알파 테스트, 베타 테스트)

4) 목적에 따른 테스트
- 회복(Recovery) 테스트 : 시스템에 고의로 실패를 유도하고 시스템이 정상적으로 복귀하는가?
- 안전(Security) 테스트 : 부당하고 불법적인 침입을 시도하여 보안시스템이 불법적인 침투를 잘 막아내는가?
- 강도(Stress) 테스트 : 시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정상적으로 작동되는가?
- 성능(Performance) 테스트 : 사용자의 이벤트에 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 테스트
- 구조(Structure) 테스트 : 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가
- 회귀(Regression) 테스트 : 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인
- 병행(Parallel) 테스트 : 변경된 소프트웨어와 기존 소프트웨어에 동일 데이터를 입력하여 결과를 비교

테스트 커버리지 유형
- 구문 커버리지 : 프로그램 내 모든 문장을 적어도 한 번 이상 실행하는 것을 기준으로 수행
- 결정 커버리지 : 결정 조건 내 전체 조건식이 최소한 참/거짓 한 번의 값을 가지도록 측정
- 조건 커버리지 : 전체 조건식 결과와 관계없이 개별 조건식이 참/거짓 한번 모두 갖도록 개별 조건식을 조합
- 조건/결정 커버리지 : 전체 조건식이 참/거짓 한번씩 가지면서 개별 조건식이 참/거짓 모두 한번씩 갖도록 
조합
- 변경/조건 결정 커버리지 : 각 개별 조건식이 다른 개별 조건식의 영향을 받지 않고 전체 조건식의 결과에 
독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상
- 다중 조건 커버리지 : 결정 조건 내 모든 개발 조건식의 모든 가능한 조합을 100% 보장

성능 테스트 도구
- 애플리케이션의 처리량, 응답시간, 경과시간, 자원사용률에 대해 가상의 사용자를 생성하고 테스트를 수행함으로써 성능 목표를 달성하였는지를 확인하는 테스트 자동화 도구

### 8. 단위 테스트(Unit Test)
- 개별 모듈을 시험하는 것으로 모듈이 정확하게 구현되었는지, 예정한 기능이 제대로 수행되는지를 점검하는
 것이 주요 목적인 테스트
- 명세 기반 테스트, 구조 기반 테스트 중에서 주로 구조 기반 테스트를 시행함

*단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은?*  
- 알고리즘 오류에 따른 원치 않는 결과
- 탈출구가 없는 반복문의 사용
- 틀린 계산 수식에 의한 잘못된 결과
- ~~모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과 => 통합 테스트~~

### 9. 통합 테스트(Integration Test)
- 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
- 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류 검사

1) 상향식 통합 테스트(Bottom Up Integration Test)
- 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법
- 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster) 필요
- 상위 모듈 개발이 완료되지 않은 경우 드라이버(Driver)를 사용하기도 한다.
- 하위 모듈들을 클러스터(Cluster)로 결합
→ 더미 모듈인 드라이버(Driver) 작성
→ 통합된 클러스터 단위로 테스트
→ 테스트 완료 후 클러스터는 프로그램 구조의 상위로 이동해 결합하고 드라이버는 실제 모듈로 대체됨

2) 하향식 통합 테스트(Top Down Integration Test)
- 깊이 우선 방식 또는 너비 우선 방식이 있다.
- 상위 컴포넌트를 테스트 하고 점증적으로 하위 컴포넌트를 테스트한다.
- 하위 컴포넌트 개발이 완료되지 않은 경우 스텁(Stub)을 사용하기도 한다.
- 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법
- 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음
- 상위 모듈에서는 테스트 케이스 사용하기 어려움
- 주요 제어 모듈은 작성된 프로그램을 사용
→ 주요 제어 모듈의 종속 모듈은 스텁(Stub)으로 대체
→ 깊이 또는 너비 우선 방식에 따라 하위 모듈인 스텁(Stub)들이 한 번에 하나씩 실제 모듈로 교체됨
→ 모듈이 통합될 때마다 테스트 실시
→ 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시
*스텁(Stub)*
- 하향식 통합 테스트를 위해 일시적으로 필요한 조건만을 가지고 제공되는 시험용 임시 모듈

3) 혼합식 통합 테스트
- 하위 수준에서는 상향식 통합을, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원하는 방식
- 샌드위치식 통합 테스트 방법

4) 빅뱅 테스트
- 통합 테스트(Integration Test) 중 비점진적 통합 방식

5) 회귀 테스트(Regression Testing)
- 이미 테스트된 프로그램의 테스팅 반복
- 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인

### 10. 인수 테스트(Acceptance Test)
- 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두는 테스트

1) 알파 테스트
- 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 검사하는 기법
- 사용자가 개발자 앞에서 검사한다.
- 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록한다.

2) 베타 테스트
- 필드 테스팅(field testing)이라고도 불리며 개발자 없이 고객의 사용 환경에 소프트웨어를 설치하여 검사를 수행하는 인수검사 기법
- 선정된 최종 사용자가 여러 명의 사용자 앞에서 검사한다.
- 통제된 환경에서 베타검사는 개발자에 의해 제어되지 않는 상태에서 검사한다.

3) 사용자 인수 테스트
4) 운영상의 인수 테스트
5) 계약 인수 테스트
6) 규정 인수 테스트

### 11. 테스트 케이스, 테스트 시나리오, 테스트 오라클, 테스트 하네스
1) 테스트 케이스(Test Case)
- 사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 
테스트 항목 명세서
- 명세 기반 테스트(블랙박스 테스트)의 설계 산출물에 해당

테스트 케이스의 구성요소
- 식별자(항목 식별자, 일련번호)
- 테스트항목(테스트 대상-모듈 또는 기능)
- 입력 명세(테스트 데이터, 테스트 조건)
- 출력 명세(예상 결과)
- 환경 설정(필요한 하드웨어나 소프트웨어의 환경)
- 특수 절차 요구(테스트 케이스 수행 시 특별히 요구되는 절차)
- 의존성 기술(테스트 케이스 간의 의존성)

테스트 케이스에 일반적으로 포함되는 항목
- 테스트 조건
- 테스트 데이터
- 예상 결과
- ~~테스트 비용~~

2) 테스트 시나리오(Test Scenario)
- 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합
- 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서

3) 테스트 오라클(Test Oracle)
- 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동을 말한다.
- 종류에는 참, 샘플링, 휴리스틱, 일관성 검사가 존재한다.
- 테스트 오라클의 특징
- 제한된 검증 : 모든 테스트 케이스에 적용할 수 없음
- 수학적 기법 : 값을 수학적 기법을 이용해 구할 수 있음
- 자동화 기능 : 프로그램 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있음

테스트 오라클의 종류
- 참(True) 오라클
- 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클
- 발생된 모든 오류를 검출할 수 있음
- 샘플링(Sampling) 오라클
- 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클
- 휴리스틱(Heuristic, 추정) 오라클
  - 샘플링 오라클 개선.
- 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고 나머지 입력 값들에 대해서는 추정으로
 처리하는 오라클
- 일관성(Consistent) 검사 오라클
- 변경이 있을 때 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클

4) 테스트 하네스(Test Harness)
- 테스트 드라이버(Test Driver)
- 시험대상 모듈을 호출하는 간이 소프트웨어이다.
- 필요에 따라 매개 변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있다.
- 상향식 통합 테스트에서 사용된다.

- 테스트 스텁(Test Stub)
- 테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다.
- 하향식 통합 테스트에서 사용된다.
- 테스트 대상의 상위 모듈을 대신하는, 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구

- 테스트 슈트(Test Suites)
- 테스트 대상 컴포넌트나 모듈 등 시스템에 사용되는 테스트 케이스의 집합


테스트 스크립트(Test Script)
- 자동화된 테스트 실행 절차에 대한 명세서

목 오브젝트(Mock Object)
- 사전에 사용자의 행위를 조건부로 입력해 두면, 그 상황에 맞는 예정된 행위를 수행하는 객체

*테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법이 아닌 것은?*
- 입력 도메인 분석
  - 랜덤 테스트
  - 자료 흐름도
- ~~스터브(Stub)와 드라이버(Driver) => 통합 테스트때 사용함~~

### 12. DRM (디지털 저작권 관리, Digital Right Management)
디지털 저작권 관리의 구성 요소
- 콘텐츠 제공자(Contents Provider) : 콘텐츠를 제공하는 저작권자
- 콘텐츠 분배자(Contents Distributor) : 암호화된 콘텐츠를 유통하는 곳이나 사람
- 콘텐츠 소비자(Customer) : 콘텐츠를 구매해서 사용하는 주체
- 패키저(Packager) : 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는다.
- 보안 컨테이너(Security Container) : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
- 클리어링 하우스(Clearing House) : 키 관리 및 라이선스 발급 관리★
- DRM 컨트롤러(DRM Controller) : 배포된 콘텐츠의 이용 권한을 통제
- ~~Dataware house~~

*디지털 저작권 관리의 기술 요소★
- 암호화(Encryption) : 콘텐츠 및 라이선스를 암호화하고 전자서명을 할 수 있는 기술
- 키 관리(Key Management) : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
- 식별 기술(Identification) : 콘텐츠에 대한 식별 체계 표현 기술
- 저작권 표현(Right Expression) : 라이선스의 내용 표현 기술
- 암호화 파일 생성(Packager) : 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
- 정책 관리(Policy Management) : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- 크랙 방지(Tamper Resistance) : 크랙에 의한 콘텐츠 사용 방지 기술
- 인증(Authentication) : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술
- 방화벽

*디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?*
     1.	콘텐츠 암호화 및 키 관리
     2.	콘텐츠 식별체계 표현
     3.	~~콘텐츠 오류 감지 및 복구~~
     4.	라이선스 발급 및 관리

### 13. 애플리케이션 성능

애플리케이션 성능
- 처리량(Throughput) : 일정 시간 내 애플리케이션이 처리하는 일의 양
- 응답 시간(Response Time) : 애플레이케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간
- 경과 시간(Turn Around Time) : 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
- 자원 사용률(Resource Usage) : 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 
네트워크 사용량 등 자원 사용률

클린 코드 작성 원칙
- 누구든지 쉽게 이해하는 코드 작성
- 다른 모듈에 미치는 영향 최소화
- 단순, 명료한 코드 작성
- 중복이 최소화된 코드 작성
- 의존성 배제, 중복성 최소화, 추상화

단순성
 - 한 번에 한 가지 처리만 수행한다.
 - 클래스/메서드/함수를 최소 단위로 분리한다.

코드의 간결성을 유지하기 위해 사용되는 지침
- 공백을 이용하여 실행문 그룹과 주석을 명확히 구분한다.
- 복잡한 논리식과 산술식은 괄호와 들여쓰기(Indentation)를 통해 명확히 표현한다.
- 빈 줄을 사용하여 선언부와 구현부를 구별한다.
- 코드의 중복을 최소화 한다.
- 누구든지 코드를 쉽게 읽을 수 있도록 작성한다.
- 간단하게 코드를 작성한다.
- ~~한 줄에 최대한 많은 문장을 코딩한다.~~
- ~~코드가 다른 모듈에 미치는 영향을 최대화하도록 작성한다.~~

공학적으로 잘된 소프트웨어(Well Engineered Software)
- 소프트웨어는 유지보수가 용이해야 한다.
- 소프트웨어는 신뢰성이 높아야 한다.
- 소프트웨어는 충분한 테스팅을 거쳐야 한다.
- ~~소프트웨어는 사용자 수준에 무관하게 일관된 인터페이스를 제공해야 한다.~~

테스트와 디버그의 목적
 - 테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다.

소스 코드 품질분석 도구의 종류
- 정적 분석도구 : pmd, cppcheck, checkstyle, SonarQube, ccm, cobertuna
- 동적 분석도구 :  Avalanche, Valgrind, valance

*소스코드 정적 분석(Static Analysis)에 관한 것이 아닌 것은?*
- 소스 코드를 실행시키지 않고 분석한다.
- 코드에 있는 오류나 잠재적인 오류를 찾아내기 위한 활동이다.
- 자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있다.
- ~~하드웨어적인 방법으로만 코드 분석이 가능하다.~~

### 14. EAI

EAI(Enterprise Application Integration)
- 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션

EAI 구축유형
1) 포인트 투 포인트(Point to Point)
- 점 대 점으로 연결하는 방식, 변경 및 재사용이 어려움
- 가장 기본적인 애플리케이션 통합 방식으로, 애플리케이션을 1:1 로 연결
2) 허브 앤 스포크(Hub & Spoke)
- 단일 접점인 허브(Hub) 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
- 확장 및 유지보수가 용이하지만 허브 장애 발생 시 시스템 전체에 영향을 미침
3) 메시지 버스(Message Bus, ESB방식)
- 애플리케이션 사이에 미들웨어를 두어 처리하는 방식★
- 확장성이 뛰어나며 대용량 처리가 가능
4) 하이브리드(Hybrid)
- Hub & Spoke와 Message Bus의 혼합방식이다.
- 필요한 경우 한 가지 방식으로 EAI구현이 가능하다.
- 데이터 병목현상을 최소화할 수 있다.

*ESB(Enterprise Service Bus)*  
- 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션
- 애플리케이션 통합 측면에서 EAI와 유사하지만 애플리케이션 보다는 서비스 중심의 통합을 지향
- 결합도(Coupling)를 약하게(Loosely) 유지함
- 관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원이 가능

### 15. 인터페이스 구현 검증 도구

- xUnit : Java(Junit), C++(Cppunit), .Net(Nunit) 등 다양한 언어를 지원하는 단위 테스트 프레임워크
- STAF
- 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
- 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 대상 프로그램을 통해 테스트를 수행하고, 통합하여 자동화하는 검증 도구
- NTAF : STAF의 장점인 재사용 및 확장성과 FitNesse의 장점인 협업 기능을 통합한 NHN(네이버)의 테스트
- FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크 자동화 프레임워크
- Selenium : 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크
- watir : Ruby 언어를 사용하는 애플리케이션 테스트 프레임워크


### 16. 개발 지원 도구


통합 개발 환경(IDE; Integrated Development Environment)
- 개발에 필요한 환경, 즉 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등의 다양한 툴을 하나의 인터페이스로 통합해 제공하는 것을 의미함
- ex. Eclipse, Visual Studio, X Code, Android Studio, IDEA

빌드 자동화 도구
- Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다.
  - 빌드 자동화 도구는 지속적인 통합개발환경에서 유용하게 활용된다.
  - 빌드 자동화 도구에는 Ant, Gradle, Jenkins 등이 있다.
- ~~Jenkins는 Groovy 기반으로 한 오픈소스로 안드로이드 앱 개발 환경에서 사용된다.~~

### 17. 해싱함수의 종류


1) 제산법(division)
- 레코드키로 해시표의 크기보다 큰 수 중에서 가장 작은소수로 나눈 나머지를 홈 주소로 삼는 방식
2) 제곱법(mid-square)
3) 폴딩법(중첩법)
- 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식
4) 숫자분석법(계수분석법) (digit analysis)
- 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
5) 기수변환법
- 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수를 절단하고, 이를 다시 주소
 범위에 맞게 조정하는 방법
6) 무작위 방법

### 18. 소프트웨어 품질


소프트웨어 품질 목표
- 이식성(Portability)
- 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력
- 정확성(Correctness)
- 시스템의 사양과 설계, 구현에 있어서 오류가 없는 정도
- 유용성(Usability)
- 쉽게 배우고 사용할 수 있는 정도를 나타내는 것
- 효율성(Efficiency)
- 요구되는 기능을 수행하기 위해 필요한 자원의 소요 정도를 의미
- 신뢰성(Reliability)
- 주어진 시간동안 주어진 기능을 오류없이 수행하는 정도를 나타내는 것
- 정확하고 일관된 결과로 요구된 기능을 수행하는 시스템 능력
- 무결성(Integrity)
- 시스템이 프로그램이나 데이터에 대한 허용되지 않거나 잘못된 접근을 막는 정도
- 적응성(Adaptablility)
- 시스템을 변경하지 않고 설계된 환경에서 뿐만 아니라 다른 응용 분야나 환경에서도 사용될 수 있는 정도
- 정밀성(Accuracy)
- 구성된 시스템에 오류가 없는 정도. 정밀성은 정확성과 다르다. 
- 정밀성은 시스템이 정확하게 구성되었는지가 아닌 시스템이 용도대로 얼마나 잘 수행하는지를 결정한다.
- 견고성(Robustness)
- 시스템이 잘못된 입력이나 악조건에서도 기능을 계속해서 수행할 수 있는 정도
- 유연성
- ~~종속성~~

*소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목이 아닌 것은?*  
- 정확성
- 무결성
- 사용성
- ~~간결성~~

### 19. 소프트웨어 패키징


- 패키징은 사용자 중심으로 진행한다.
- 신규 및 변경 개발소스를 식별하고, 이를 모듈화하여 상용제품으로 패키징 한다.
- 고객의 편의성을 위해 매뉴얼 및 버전관리를 지속적으로 한다.
- 범용 환경에서 사용이 가능하도록 일반적인 배포 형태로 패키징이 진행된다.

패키징 작업 순서
- 기능 식별→ 모듈화→ 빌드 진행→ 사용자 환경 분석→ 패키징 및 적용 시험→ 패키징 변경 개선→ 배포

*제품 소프트웨어 패키징 도구 활용 시 고려사항*  
- 반드시 내부 콘텐츠에 대한 암호화 및 보안을 고려한다.
- 사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.
- 제품 소프트웨어 종류에 적합한 암호화 알고리즘을 적용한다.
- 추가로 다양한 이기종 연동을 고려한다.
- ~~보안상 단일 기종에서만 사용할 수 있도록 해야 한다.~~
- ~~내부 콘텐츠에 대한 보안은 고려하지 않는다.~~
- ~~보안을 위하여 이기종 연동을 고려하지 않아도 된다.~~

### 20. 연산식 표기법


- 전위 표기법(prefix) - 연산자가 앞에
- 중위 표기법(infix) - 연산자가 안에
- 후위 표기법(postfix ) - 연산자가 뒤에

<img width="487" alt="image" src="https://user-images.githubusercontent.com/71093890/222945613-f8cccca9-577d-440d-b684-7c0f9617d29b.png">


### 21. JSON, AJAX, XML

JSON(JavaScript Object Notation)
- 웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성·값의 쌍 형태로 
표현하는 형식으로 자바스크립트(JavaScript)를 토대로 개발되어진 형식

XML(eXtensible Markup Language)
- 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어

AJAX(Asynchronous JavaScript and XML)
- JavaScript를 사용한 비동기 통신기술로 클라이언트와 서버 간에 XML 데이터를 주고 받는 기술

### 22. 기타

모듈
- 소프트웨어 구조를 이루며, 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위이다.
- 하나 또는 몇 개의 논리적인 기능을 수행하기 위한 명령어들의 집합이라고도 할 수 있다.
- 서로 모여 하나의 완전한 프로그램으로 만들어질 수 있다.

Fault
- 소프트웨어 개발 활동을 수행함에 있어서 시스템이 고장(Failure)을 일으키게 하며, 오류(Error)가 있는 경우 발생하는 것

외계인코드(Alien Code)
- 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램

**제품 소프트웨어의 사용자 매뉴얼 작성절차**  
- 작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토

**소프트웨어 설치 매뉴얼에 포함될 항목**  
- 제품 소프트웨어 개요
- 설치 관련 파일
- 프로그램 삭제
- ~~소프트웨어 개발 기간~~

*S/W 유지보수 작업의 목적이 아닌 것은?*
- ~~설계수정~~
- 예방조치
- 환경적응
- 하자보수

*소프트웨어 재공학이 소프트웨어 재개발에 비해 갖는 장점*
- 위험부담 감소
- 비용 절감
- 시스템 명세의 오류억제
- 개발시간의 감소

S/W 재공학 관점에서 가장 연관 깊은 유지보수 유형
- Preventive maintenance (예방 유지보수)

S/W재공학 활동 중 기존 S/W를 다른 운영체제나 하드웨어 환경에서 사용할 수 있도록 변환하는 작업
- 이식(Migration)

