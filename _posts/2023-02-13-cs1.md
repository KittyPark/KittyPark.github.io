---
layout : post
title : 정보처리기사 필기(소프트웨어 설계)
date: '2023-02-13 11:11:00 +09:00'
categories : [Study,CS]
tags : [정보처리기사,자격증,정처기] #소문자만 가능
---


### <1과목 소프트웨어 설계>

#### 1. 애자일 방법론(Agile)

- 빠른 릴리즈를 통해 문제점을 빠르게 파악.
- 진화하는 요구사항을 수용하는데 적합.
- 소프트웨어가 잘 실행되는데 가치를 둠.
- 변화에 대응하는 것에 가치를 둠.
- 고객과의 의사소통,피드백 중요
- 절차나 도구보다 개인과의 소통이 더 중요.
- 계약 협상보다는 고객과의 협업에 더 가치를 둠
- 프로세스의 도구보다는 개인과의 상호작용에 더 가치를 둠.


#### 2. XP(eXtreme Programming) 기법
    [XP의 핵심가치]

    용기(Courage)
    의사소통(Communication)
    피드백(Feedback)
    존중(Respect)
    단순성(Simplicity)

<br>


    [XP의 기본원리]

    Continuous Integration (지속적인 통합)
    Collective Ownership (공동 소유권)
    Pair Programming (짝 프로그래밍)
    Whole Team(전체 팀)
    Small Releases(소규모 릴리즈)
    Test-Driven Development(테스트 주도 개발)
    Design Improvement(디자인 개선)

<br>

    [xp의특징]

    사용자의 요구사항은 언제든지 변할 수있다.
    
    고객과 직접 대면하며 요구사항을 이야기하기 위해 사용자 스토리(User Story)를 활용할 수 있다.

    기존의 방법론에 비해 실용성(Pragmatism)을 강조한 것이라고 볼 수있다.

#### 3. UML
    
[구성 요소]
- 사물(Things)
- 관계(Relationship)
- 다이어그램(Diagram)


---


1) 사물(Things)
- 구조 사물, 행동 사물, 그룹 사물, 주해 사물


---

1) 관계(Relationships)

**연관 관계(Association)**
- 두 사물간의 구조적 관계로 어느 한 사물 객체가 다른 사물 객체와 연결되어 있음 ('has-a')관계
- 기호 ㅡ로 표시

**일반화 관계(Generalization)**
- 일반화된 사물과 좀 더 특수화된 사물 사이의 관계
- 일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)이라고 함 ('is-a')관계
- 기호 ㅡ▷로 표시
ex. 아래의 UML 모델에서 '차' 클래스와 각 클래스의 관계는? 일반화 관계


**의존 관계(Dependency)**
- 한 사물의 명세가 바뀌면 다른 사물에 영향을 준다.
- 일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우에 나타나는 관계
- 기호 -->로 표시

**실체화 관계(Realization)**
- 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계이다.
- 기호 --▷로 표시


---

3) 다이어그램

**정적 다이어그램(Structural Diagram) => 구조적 (Structural)**

● 클래스 다이어그램(Class Diagram)
- 시스템 내 클래스의 정적 구조를 표현하고 클래스와 클래스, 클래스의 속성 사이의 관계를 나타낸다.

● 객체 다이어그램(Object Diagram)

● 컴포넌트 다이어그램(Component Diagram)

● 배치 다이어그램(Deployment Diagram)

● 복합체 구조 다이어그램(Composite Structure Diagram)

● 패키지 다이어그램(Package Diagram)

---

**동적 다이어그램(Behavioral Diagram) => 행위 (Behavioral)**

● 유스케이스 다이어그램(Use Case Diagram)
- 사용자의 요구를 추출하고 분석하기 위해 주로 사용한다.
- 연동의 개념은 양방향으로 데이터를 파일이나 정해진 형식으로 넘겨주는 것이다
- 액터는 대상 시스템과 상호 작용하는 사람이나 다른 시스템에 의한 역할이다.
- 시스템 액터는 본 시스템과 데이터를 주고받는 연동 시스템을 의미한다.
- 사용자 액터는 기능을 요구하는 대상이나 시스템의 수행결과를 통보받는 사용자 혹은 기능을 사용하게 될 
대상으로 시스템이 제공해야하는 기능인 유스케이스의 권한을 가지는 대상, 역할이다.
    
    *유스케이스 구성요소와의 관계*
- 연관 : 유스케이스와 액터의 관계
- 확장 : 기본 유스케이스 수행 시 특별한 조건을 만족할 때 수행하는 유스케이스
- 포함 : 시스템의 기능이 별도의 기능을 포함
- 일반화 : 하위 유스케이스(액션)이 상위 유스케이스(액터)에게 기능/역할을 상속받음
- 그룹화 : 여러개의 유스케이스를 단순화하는 방법


---


● 시퀀스(순차) 다이어그램(Sequence Diagram)
- 객체들의 상호 작용을 나타내기 위해 사용한다.
- 시간의 흐름에 따라 객체들이 주고 받는 메시지의 전달 과정을 강조한다.
- 교류 다이어그램(Interaction Diagram)의 한 종류로 볼 수 있다.
- 정적 다이어그램보다 동적 다이어그램에 가깝다.

    *순차 다이어그램의 구성 항목 # 액객생메실*
- 액터(Actor) : 시스템으로부터 서비스를 요청하는 외부요소로, 사람이나 외부 시스템 의미
- 객체(object) : 메시지를 주고받는 주체
- 생명선(Life line) : 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현
- 메시지(Message) : 객체가 상호 작용을 위해 주고받는 메시지
- 실행 상자(Active Box) : 객체가 메시지를 주고받으며 구동되고 있음을 표현


---


● 액티비티(활동) 다이어그램 (Activity Diagram)
- 시스템이 어떤 기능을 수행하는지 객체의 처리로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다.


---


● 상태 다이어그램(State Diagram)
- 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태 변화를 표현한다.


---


● 상호작용 개요 다이어그램(Interaction Overview Diagram)

● 커뮤니케이션 다이어그램(Communication Diagram)

● 타이밍 다이어그램(Timing Diagram)

---


*UML에 대한 설명 중 옳지 않은 것은?*

- 기능적 모델은 사용자 측면에서 본 시스템 기능이며, 유스케이스 다이어그램을 사용한다.
- 정적 모델은 객체, 속성, 연관관계, 오퍼레이션의 시스템의 구조를 나타내며, 클래스 다이어그램을 사용한다.
- 동적 모델은 시스템의 내부 동작을 말하며, UML에서는 시퀀스, 상태, 액티비티 다이어그램을 사용한다.

    ~~상태 다이어그램은 객체들 사이의 메시지 교환을 나타내며, 시퀀스 다이어그램은 하나의 객체가 가진 상태와 그 상태의 변화에 의한 동작순서를 나타낸다.~~

*컴포넌트 다이어그램과 배치 다이어그램은 구현 단계에서 사용되는 다이어그램이다.*

*UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호 : 《 》*

---

#### 4. UI (User Interface)

[UI의 구분]
- CLI (Command Line Interface) : 대표적으로 DOS 및 Unix 등의 운영체제에서 조작을 위해 사용하던 것으로, 
정해진 명령문자열을 입력하여 시스템을 조작하는 사용자 인터페이스
- GUI (Graphical User Interface) : 마우스로 선택해 작업을 하는 그래픽 환경의 인터페이스
- NUI (Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
- VUI (Voice User Interface) : 사람의 음성으로 기기를 조작하는 인터페이스
- OUI (Organic User Interface) : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

---


[UI의 기본 원칙]
- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 한다.
- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 한다.
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.


---


[UI의 특징]
- 사용자와 시스템이 정보를 주고받는 상호작용이 잘 이루어지도록 하는 장치나 소프트웨어를 의미한다.
- 편리한 유지보수를 위해 사용자 중심으로 설계되어야 한다.
- 사용자 중심의 상호 작용이 되도록 한다.
- 배우기가 용이하고 쉽게 사용할 수 있도록 만들어져야 한다.
- 사용자 요구사항이 UI에 반영될 수 있도록 구성해야 한다.
- 구현하고자 하는 결과의 오류를 최소화한다.
- 사용자의 편의성을 높임으로써 작업시간을 단축시킨다.
- 막연한 작업 기능에 대해 구체적인 방법을 제시하여 준다.


---

#### 5. CASE (Computer-Aided Software Engineering)
- 소프트웨어 개발 과정의 일부 또는 전체를 자동화하기 위한 도구이다.
- 소프트웨어 모듈의 재사용성이 향상된다.
- 표준화된 개발 환경 구축 및 문서 자동화 기능을 제공한다.
- 자동화된 기법을 통해 소프트웨어 품질이 향상된다.
- 작업 과정 및 데이터 공유를 통해 작업자간 커뮤니케이션을 증대한다.
- 소프트웨어 유지보수를 간편하게 수행할 수 있다.
- 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사, 디버깅 과정 전체 또는 일부를 컴퓨터와 전용의 소프트웨어 도구를 사용하여 자동화하는 것이다.

~~-소프트웨어 사용자들에게 사용 방법을 신속히 숙지시키기 위해 사용된다.~~

~~2000년대 이후 소개되었으며, 객체지향 시스템에 한해 효과적으로 활용된다. => 1980년대, 모든 분야에 적용~~

---


**CASE의 주요 기능**
- 그래픽 지원
- 소프트웨어 생명주기 전 단계의 연결
- 다양한 소프트웨어 개발 모형 지원
~~- 언어 번역~~
- 모델들 사이의 모순검사
- 오류검증
- 자료흐름도 등 다이어그램 작성
- 시스템 문서화 및 명세화를 위한 그래픽 지원

---

**CASE의 원천 기술**
- 자동프로그래밍 기술
- 분산 처리 기술
- 구조적 기법
- 프로토타이핑 기술
- 정보 저장소 기술
~~- 일괄처리 기술~~

---


**CASE 도구의 분류**

1) 상위 CASE 도구 : 요구분석, 설계 단계를 지원

    <span style="color:blue">모델들 사이의 모순 검사 기능</span>
    <br>
    <span style="color:blue">모델의 오류검증 기능</span> 
    <br>
    <span style="color:blue">자료 흐름도 작성 기능</span>

2) 하위 CASE 도구 : 코드를 작성하고 테스트하며 문서화하는 과정 지원

    <span style="color:blue">시스템 명세서 </span>
    <br>
    <span style="color:blue">전체 소스코드 생성 기능</span>

---


#### 6. 요구사항 개발 프로세스

요구사항 개발 프로세스
- 도출/추출(Elicitation) → 분석(Analysis) → 명세(Specification) → 확인(Validation)/검증(Valification)

---


① 요구사항 추출(Requirement Elicitation)
- 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계이다.

---

② 요구사항 분석(Requirement Analysis)
- 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대해 이해하는 단계라 할 수 있다.
- 도메인 분석(Domain Analysis)은 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 한다.
- 분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용 활 수 있다.
- 자료흐름도, 자료 사전 등이 효과적으로 이용될 수 있다.
- 보다 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 활용될 수 있다.
  
~~개발 비용이 가장 많이 소요되는 단계이다.~~

~~기능적(Functional) 요구에서 시스템 구축에 대한 성능, 보안, 품질, 안정 등에 대한 요구사항을 도출한다.~~
- 비용과 일정에 대한 제약설정
- 타당성 조사
- 요구사항 정의 문서화  
~~설계 명세서 작성~~

---

기능적 요구사항, 비기능적 요구사항
- 기능적 요구사항 : 시스템에서 제공해야 할 기능을 정의한 것
- 입출력기능, 데이터베이스 기능, 통신 기능 등
- 비기능적 요구사항 : 시스템이 가져야 하는 기능 이외의 요구사항
- 시스템의 전체적인 품질이나 고려해야 하는 제약사항 등
- 사용 용이성, 효율성, 신뢰성, 이식성, 유연성, 확장성
- 성능적인 면: 응답 속도, 자원 사용량 등
- 보안 측면: 침입 대응, 침입 탐지, 사용자 인증, 권한 부여 등

요구사항 분석 시에 필요한 기술
- 청취과 인터뷰 질문 기술
- 분석과 중재기술
- 관찰 및 모델 작성 기술  
~~설계 및 코딩 기술~~

요구사항 분석이 어려운 이유
- 개발자와 사용자 간의 지식이나 표현의 차이가 커서 상호 이해가 쉽지 않다.
- 사용자의 요구는 예외가 많아 열거와 구조화가 어렵다.
- 사용자의 요구사항이 모호하고 불명확하다.
- 소프트웨어 개발 과정 중에 요구사항이 계속 변할 수 있다.

---

③ 요구사항 명세(Requirements Specification)
- 비정형 명세기법은 사용자의 요구를 표현할 때 자연어를 기반으로 서술한다.  
~~비정형 명세기법은 사용자의 요구를 표현할 때 Z 비정형 명세기법을 사용한다.~~
- 정형 명세기법은 사용자의 요구를 표현할 때 수학적인 원리와 표기법을 이용한다.
- 정형 명세기법은 비정형 명세기법에 비해 표현이 간결하다.
*정형 명세기법(수학적 기반) : Z, VDM, Petri-Net, CSP, CCS, LOTOS*
*비정형 명세기법(자연어 기반) : FSM, Decision Table, ER모델링, State chart(SADT), UseCase*

---

④ 요구사항 검증(Requirements Validation)
- 요구사항이 고객이 정말 원하는 시스템을 제대로 정의하고 있는지 점검하는 과정이다.
- 개발완료 이후에 문제점이 발견될 경우 막대한 재작업 비용이 들 수 있기 때문에 매우 중요하다.
- 요구사항이 실제 요구를 반영하는지, 문서상의 요구사항은 서로 상충되지 않는지 등을 점검한다.  
~~요구사항 검증 과정을 통해 모든 요구사항 문제를 발견할 수 있다~~
- 인터페이스 요구사항 검토 계획 수립 → 검토 및 오류 수정 → 베이스라인 설정

요구사항 검증 방법
- 동료 검토(Peer Review)
- 요구 사항 명세서 작성자가 요구 사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견
- 인스펙션(Walk Through)
- 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 확인하면서 결함을 발견
- 워크 스루(Inspection)
- 검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토 후, 짧은 검토 회의를 통해 오류를 조기 검출

<br>


*다음 중 요구사항 모델링에 활용되지 않은 것은?*
- 애자일(Agile) 방법
- 유스케이스 다이어그램(Use Case Diagram)
- 시퀀스 다이어그램(Sequence Diagram)  
~~단계 다이어그램(Phase Diagram)~~

<br>

*요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서 사용되는 다이어그램이 아닌 것은?*
- Data Flow Diagram
- UML Diagram
- E-R Diagram  
~~AVL Diagram~~

<br>

*요구사항 관리 도구의 필요성이 아닌 것은?
- 요구사항 변경으로 인한 비용 편익 분석
- 요구사항 변경의 추적
- 요구사항 변경에 따른 영향 평가  
~~기존 시스템과 신규 시스템의 성능 비교~~

---


#### 7. 미들웨어(Middleware)

     분산 컴퓨팅 환경에서 서로 다른 기종 간의 하드웨어나
     프로토콜, 통신환경 등을 연결하여 응용프로그램과 
     운영환경 간에 원만한 통신이 이루어질 수 있게 서비스를
     제공하는 소프트웨어

- 분산 시스템에서 다양한 부분을 관리하고 통신하며 데이터를 교환하게 해주는 소프트웨어로 볼 수 있다.
- 위치 투명성(Location Transparency)을 제공한다.
- 분산 시스템의 여러 컴포넌트가 요구하는 재사용 가능한 서비스의 구현을 제공한다.
- 애플리케이션과 사용자 사이 외에도 프로그램과 환경 간에서 분산서비스를 제공한다.
- 클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어  
~~애플리케이션과 사용자 사이에서만 분산서비스를 제공한다.~~

---

DB(Database)
- 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어


---


WAS(Web Application Server, 앱 애플리케이션 서버)
- 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
- ex. Web Logic, WebSphere, JEUS, Tomcat, ~~Web Server~~


---


RPC(Remote Procedure Call, 원격 프로시저 호출)
- 응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어


---


TP Monitor(Transaction Processing Monitor, 트랜잭션 처리 모니터)
- 트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어
- 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용됨


---


MOM(Message Oriented Middleware, 메시지 지향 미들웨어)
- 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어


---


Legacyware(레거시웨어)
- 기존 애플리케이션에 새로운 업데이트된 기능을 덧붙이고자 할 때 사용되는 미들웨어


---


ORB(Object Request Broker, 객체 요청 브로커)
- 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
- 객체 간 메시지 전달을 지원하는 미들웨어
- 코바(CORBA) : 네트워크에서 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격을 의미


---


#### 8. 디자인 패턴
디자인 패턴을 목적(Purpose)으로 분류할 때 생성, 구조, 행위로 분류할 수 있다.

디자인 패턴 사용의 장단점
- 개발자들 사이의 의사소통을 원활하게 할 수 있다.
- 소프트웨어의 품질과 생산성을 향상시킬 수 있다.
- 소프트웨어 구조 파악이 용이하다.
- 재사용을 위한 개발 시간이 단축된다.
- 개발 프로세스를 무시할 수 있다.
- 절차형 언어와 함께 이용될 때 효율이 극대화된다.

---


**1) 생성 패턴(Creational Pattern) #추빌팩프싱**

● 추상 팩토리 패턴(Abstract Factory)
- 서로 연관, 의존하는 객체들을 그룹으로 생성해 추상적으로 표현한다.
● 빌더 패턴(Builder)
- 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성한다
● 팩토리 메소드 패턴(Factory Method)
= Virtual-Constructor 패턴 (가상 생성자)
- 상위클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위클래스에서 인스턴스를 생성한다.
- 객체를 생성하기 위한 인터페이스를 정의하여, 어떤 클래스가 인스턴스화 될 건지는 서브클래스가 결정한다.
● 프로토타입 패턴(Prototype)
- prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.
● 싱글톤 패턴(Singleton)
- 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다.

---


**2) 구조 패턴(Structural Pattern) # 어브컴데퍼플프**

● 어댑터 패턴(Adapter)
- 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰준다.
● 브리지 패턴(Bridge)
- 구현부에서 추상층을 분리하여, 독립적으로 확장이 가능하게 하는 패턴
- 기능과 구현을 두 개의 별도 클래스로 구현함
● 컴포지트 패턴(Composite)
- 여러 객체를 가진 복합, 단일 객체를 구분 없이 다룰 때 사용하는 패턴
● 데코레이터 패턴(Decorator)
- 상속을 사용하지 않고도 객체의 기능을 동적으로 확장해주는 패턴
● 퍼싸드 패턴(Façade)
- 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴; ex) 리모컨
● 플라이웨이트 패턴(Flyweight)
- 공유해서 사용함으로써 메모리를 절약하는 패턴
● 프록시 패턴(Proxy)
- 접근이 어려운 객체를 연결해주는 인터페이스 역할을 수행하는 패턴

---


**3) 행위 패턴(Behavioral Pattern) : 행위의 변경, 수정 등을 위한 패턴**
    
    클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.

● 책임 연쇄 패턴(Chain of Responsibility)

    한 객체가 처리하지 못하면 다음 객체로 넘어가는 패턴
● 커맨드 패턴(Command)

    요청에 사용되는 각종 명령어들을 추상, 구체 클래스로 분리하여 단순화함
● 인터프리터 패턴(Interpreter)
    
    언어에 문법 표현을 정의하는 패턴
● 반복자 패턴(Iterator)
    
    동일한 인터페이스를 사용하도록 하는 패턴
● 중재자 패턴(Mediator)
    
    객체간의 통제와 지시의 역할을 하는 중재자를 두어 
    객체지향의 목표를 달성하게 해준다.
● 메멘토 패턴(Memento)

    요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
● 옵저버 패턴(Observer)
  
    관찰대상의 변화를 탐지하는 패턴
    한 객체의 상태가 변화하면 객체에 상속되어 있는 
    다른 객체들에게 변화된 상태를 전달
- 분산된 시스템 간에 이벤트 생성, 발행(Publish), 이를 수신(Subscribe)해야 할 때 이용함

● 상태 패턴(State)
    
    객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
● 전략 패턴(Strategy)
    
    클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하는 패턴

● 템플릿 메소드 패턴(Template Method)
    
    유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에 정의하는 패턴
● 방문자 패턴(Visitor)
    
    필요할 때마다 해당 클래스에 방문해서 처리하는 패턴
    각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성한다.
    분리된 처리 기능은 각 클래스를 방문하여 수행

---

#### 9. 객체지향

객체(Object)
- 실세계에 존재하거나 생각할 수 있는 것을 말한다.

클래스(Class)
- 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것이다.
- 객체지향 프로그램에서 데이터를 추상화하는 단위

인스턴스(Instance)
- 같은 클래스에 속한 각각의 객체를 의미한다.

메서드(Method)
 - 클래스로부터 생성된 객체를 사용하는 방법

메시지(Message)
 - 객체에게 어떤 행위를 하도록 지시하는 명령

캡슐화(encapsulation)
- 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러낸다.
- 객체지향에서 정보 은닉과 가장 밀접한 관계가 있는 것
- 인터페이스가 단순화 된다.
- 소프트웨어 재사용이 높아진다.
- 변경 발생 시 오류의 파급효과가 적다.
- 데이터와 데이터를 처리하는 함수를 하나로 묶는 것이다.
- 캡슐화된 객체의 세부 내용이 외부에 은폐되어 변경이 발생하게되 오류의 파급 효과가 적다.
- 인터페이스가 단순해지고 객체 간의 결합도가 낮아진다.
- 캡슐화된 객체들은 재사용이 용이해진다.

정보 은닉(Information Hiding)
- 객체가 가지고 있는 속성과 오퍼레이션의 일부를 감추어서 객체의 외부에서는 접근이 불가능하다
- 필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부시스템이 다른 모듈의 구현에 영향을 받지 않게 설계되는것을 의미한다.
- 모듈들 사이의 독립성을 유지시키는 데 도움이 된다.
- 설계에서 은닉되어야 할 기본 정보로는 IP주소와 같은 물리적 코드, 상세 데이터 구조 등이 있다.  
~~모듈 내부의 자료 구조와 접근 동작들에만 수정을 국한하기 때문에 요구사항 등 변화에 따른 수정이 불가능하다. => 모듈 변경 시 영향을 받지 않아 수정, 시험, 유지보수 용이~~

상속(Inheritance)
- 상위클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다.
- 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것을 의미한다.

다형성(Polymorphism)
- 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질이다.

일반화(Generalization)
- 공통 성질을 상위 객체로 정의하고, 특수화된 객체들을 하위의 부분형 객체로 정의하는 추상화 방법이다.
- is a : 클래스들 간의 개념적인 포함 관계

집단화(Aggregation)
- 클래스들 사이의 ‘부분-전체(part-whole)' 또는 ’부분(is-a-part-of)'의 관계로 설명되는 연관성을 나타낸다.
- 클래스 간의 구조적인 집약 관계 "클래스 A는 클래스 B와 클래스 C로 구성된다"
- 서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체를 만드는 것이다.

추상화(Abstraction)
- 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시키는 것
*소프트웨어 설계에 사용되는 대표적인 3가지 추상화 기법
- 제어 추상화, 과정 추상화, 자료 추상화, 강도 추상화


객체지향 설계 원칙 #SOLID

● SRP, 단일 책임 원칙(Single Responsibility Principle)
    
    객체는 단 하나의 책임만 가져야 한다.
● OCP, 개방-폐쇄 원칙(Open-Closed Principle)

    기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
    확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다
● LSP, 리스코프 치환 원칙(Liskov Substitution Principle)
    
    서브타입(상속받은 하위 클래스)은 어디에서나 자신의 기반타입(상위클래스)으로 교체할 수 있어야 한다.
● ISP, 인터페이스 분리 원칙(Interface Segregation Principle)
    
    클라이언트는 자신이 사용하지 않는 메서드와 의존관계를 맺으면 안된다.
    클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안된다.
● DIP, 의존 역전 원칙(Dependency Inversion Principle)
    
    의존 관계를 맺을 때, 변화하기 쉬운 것보다 변화하기 어려운 것에 의존해야 한다.

---

**객체지향 분석 방법론**

1) Coad와 Yourdon 방법
    
    E-R 다이어그램을 사용하여 객체의 행위를 데이터 모델링하는데 초점을 둔 방법이다.
    
    객체 식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것
2) Booch 방법(부치)
   
    미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 방법이다.
3) Jacobson 방법
    
    Use-Case를 강조하여 사용하는 방법이다.
4) Wirfs-Brocks 방법

    분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 분석 방법

객체지향 분석 기법의 특징
- 동적 모델링 기법이 사용될 수 있다.
- 데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업이다.
- 소프트웨어를 개발하기 위한 비즈니스(업무)를 객체/속성, 클래스/멤버, 전체/부분 등으로 나눠 분석한다.
- 코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다.    
~~기능 중심으로 시스템을 파악하며 순차적인 처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.~~


---


#### 10. 럼바우의 객체지향 분석 기법

- 객체 모델링 : 객체 다이어그램(정보 모델링)
- 동적 모델링 : 상태 다이어그램(상태도)
- 기능 모델링 : 자료 흐름도(DFD)

---


#### 11. DFD (자료 흐름도, Data Flow Diagram)

자료 흐름도의 구성요소
- 프로세스(Process) => 원으로 표시
- 자료 흐름(Data Flow) => 화살표로 표시
- 자료 저장소(Data Store) => 평행선으로 표시
- 단말(Terminator) => 사각형으로 표시

자료 흐름도의 특징
- 자료 흐름 그래프 또는 버블(bubble) 차트라고도 한다.
- 구조적 분석 기법에 이용된다.
- 시간 흐름을 명확하게 표현할 수 없다.
- 자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화된다.
- DFD의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시한다.


---

#### 12. 자료사전 기호

    = : 자료의 정의 (is composed of)
    + : 자료의 연결 (and)
    ( ) : 자료의 생략 (optional)
    [ ] : 자료의 선택. (or)
    { } : 자료의 반복 (iteration of)
    * * : 자료의 설명(주석, comment)
    
    
---


#### 13. 소프트웨어 설계

바람직한 소프트웨어 설계 지침
- 모듈의 기능을 예측할 수 있도록 정의한다.
- 이식성을 고려한다.
- 적당한 모듈의 크기를 유지한다.
- 가능한 모듈을 독립적으로 생성하고 결합도를 최소화한다.
- 적당한 모듈의 크기를 유지한다.
  - 모듈 간의 접속 관계를 분석하여 복잡도와 중복을 줄인다.
  - 모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.
- 모듈 간의 결합도는 약할수록 바람직하다. (응집도는 강할수록 좋다)

소프트웨어의 상위 설계 : 최하위 수준에서 각각의 모듈들을 설계하고, 모듈이 완성되면 이들은 결합하여 검사
- 데이터 설계
- 시스템 분할
- 아키텍처 설계
- 인터페이스 정의
- 사용자 인터페이스 설계

소프트웨어의 하위 설계 : 소프트웨어 설계시 제일 상위에 있는 main user function에서 시작하여 기능을 하위 기능들로 분할해 가면서 설계하는 방식
- 모듈 설계
- 인터페이스 작성

*소프트웨어 아키텍처 설계에서 시스템 품질 속성이 아닌 것은?*
- 가용성 (Availability)
- 변경 용이성 (Modifiability)
- 사용성(Usability)  
~~독립성 (Isolation)~~

*소프트웨어의 사용자 인터페이스 개발 시스템(User Interface Development System)의 기능이 아닌 것은?*
- 사용자 입력의 검증
- 에러 처리와 에러 메시지 처리
- 도움과 프롬프트(prompt) 제공  
~~소스 코드 분석 및 오류 복구~~

*소프트웨어 설계시 구축된 플랫폼의 성능특성 분석에 사용되는 측정 항목이 아닌 것은?*
- 응답시간(Response Time)
- 가용성(Availability) 
- 사용률(Utilization)  
~~서버 튜닝(Server Tuning)~~

*소프트웨어 공학에서 모델링 (Modeling)의 특징이 아닌 것은?*
- 개발팀이 응용문제를 이해하는 데 도움을 줄 수 있다.
- 개발될 시스템에 대하여 여러 분야의 엔지니어들이 공통된 개념을 공유하는 데 도움을 준다.
- 절차적인 프로그램을 위한 자료 흐름도는 프로세스 위주의 모델링 방법이다.  
~~유지보수 단계에서만 모델링 기법을 활용한다.~~

*소프트웨어 프로젝트 계획 수립 시 소프트웨어 영역(software scope) 결정사항에 기술될 주요사항이 아닌 것은?*
- 기능
- 제약조건
- 인터페이스  
~~인적자원~~

---

#### 14. 소프트웨어 아키텍처 패턴

1) 레이어 패턴(Layers Pattern)
- 계층 모델이라고도 한다. (ex. OSI 7계층)

2) 클라이언트-서버 패턴(Client-Server Pattern)
- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
- 클라이언트나 서버는 요청과 응답을 받기 위해 동기화 되는 경우를 제외하고는 서로 독립적이다.

3) 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)
- 3개의 서브시스템(모델, 뷰, 제어)으로 구성되어 있다.

4) 파이프 필터 패턴(Pipe-Filter Pattern)
- 데이터는 파이프를 통해 단방향으로 흐르며, 필터 이동 시 오버헤드가 발생할 수 있다.
- 서브시스템이 입력 데이터를 받아 처리하고 결과를 다른 시스템에 보내는 작업이 반복한다.
- ex. UNIX의 쉘(Shell)

5) 마스터-슬레이브 구조(Master-Slave Pattern)
- 일반적으로 실시간 시스템에서 사용된다.
- 마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임진다.
- 마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있다.  
~~슬레이브 프로세스는 데이터 수집 기능을 수행할 수 없다.~~  
- ex. 장애 허용 시스템, 병렬 컴퓨팅 시스템

6) 브로커 구조(Broker Pattern)
- 컴포넌트와 사용자를 연결해주는 패턴
- ex. 분산 환경 시스템

7) 피어-투-피어 구조(Peer-To-Peer Pattern)
- 피어를 하나의 컴포넌트로 간주한다.
- 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴
- ex. 멀티스레딩(Multi Threading) 방식 사용

8) 이벤트-버스 구조(Event-Bus Pattern)
- 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식
- 이벤트를 생성하는 소스(Source), 이벤트를 수행하는 리스너(Listener), 이벤트의 통로인 채널(Channel), 채널들을 관리하는 버스(Bus)

9) 블랙보드 구조(Blackboard Pattern)
- 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴
- ex. 음성인식, 차량 식별, 신호 해석 

10)  인터프리터 구조(Interpreter Pattern)
- 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용

---


#### 15. 코드

코드의 기본 기능 : 배열, 분류, 식별, 표준화, ~~복잡성~~, 간소화, 연상, 암호화, 오류 검출 기능

코드의 분류
1) 순차 코드(Sequence Code, 일련 번호 코드)
  - 코드 설계에서 일정한 일련번호를 부여하는 방식
- ex) 1, 2, 3, 4, …

2) 블록 코드(Block Code, 구분 코드)
- 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법
- 코드화 대상을 미리 파악하여 블록으로 구분한 후 그 안에서 순서대로 코드를 부여
- ex) 1001~1100: 총무부, 1101~1200: 영업부

3) 10진 코드(Decimal Code, 도서 분류식 코드)
- 0~9까지 10진 분할하고, 다시 각각에 대해 10진 분할하는 방법을 필요한 만큼 반복하는 방법
- 코드화 대상물을 일정한 소속으로 구분하여 십진수 한 자리씩 구분하여 대분류하고, 같은 방법으로 중    분류, 소분류한 코드
- ex) 1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계

4) 그룹 분류 코드(Group Classification Code)
- 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
- 구분 코드를 세분화한 형태로 대분류, 중분류, 소분류 등 각 분류별로 자릿수를 구성
- ex) 1-01-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계

5) 연상 코드(Mnemonic Code, 기호 코드)
- 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
- 숫자나 문자를 조합해서 나타내는 것으로 어떤 내용을 기억할 수 있도록 표시한 기호 코드
ex) TV-40: 40인치 TV, L-15-220: 15W 220V 램프

6) 표의 숫자 코드(Significant Digit Code, 유효 숫자 코드) 
- 코드화 대상 항목의 중량, 면적, 용량 등의 물리적 수치를 이용하여 만든 코드
- ex) 120-720-1500: 두께X폭X길이가 120X720X1500인 강판

7) 합성 코드(Combined Code)
- 2개 이상의 코드를 조합하여 만드는 방법
- ex) 연상 코드+순차 코드 → KE-711: 대한항공 711기, AC-253: 에어캐나다 253기

8) 코드 부여 체계
- 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식
- 각 개체에 유일한 코드 부여하여 개체들의 식별 및 추출을 용이하게 함
- 코드를 부여하기 전 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드가 정의되야 함
- ex) PJC-COM-003: 전체 시스템 단위의 3번째 공통 모듈
- ex) PY3-MOD-010: PY3라는 단위 시스템의 10번째 모듈


---


#### 16. 기타

시스템의 구성요소
- 입력(Input), 출력(Output), 처리(Process), 제어(Control), 피드백(Feedback), ~~유지보수(Maintenance)~~

연계시스템 구성 요소
1) 송신 시스템
- 시스템 인터페이스를 구성하는 시스템으로, 연계할 데이터를 데이터베이스와 애플리케이션으로부터 연계 
테이블 또는 파일 형태로 생성하여 송신하는 시스템이다.
2) 수신 시스템
- 수신한 연계테이블, 파일데이터를 수신시스템에서 관리하는 데이터 형식에 맞게 변환하여 DB에 저장하거나 
애플리케이션에서 활용할 수 있도록 제공
3) 중계 서버
- 송/수신 시스템 사이에서 데이터를 송수신하고, 연계데이터의 송수신 현황을 모니터링함, 연계데이터의 
보안강화 및 다중플랫폼 지원 등이 가능

현행 시스템 분석에서 고려하지 않아도 되는 항목은?
- DBMS 분석
  - 네트워크 분석
  - 운영체제 분석  
  ~~인적자원 분석~~

HIPO(Hierarchy Input Process Output)
- 하향식 소프트웨어 개발을 위한 문서화 도구이다.
- HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.
- 기능과 자료의 의존 관계를 동시에 표현할 수 있다.
- 보기 쉽고 이해하기 쉽다.

DBC(Design by Contract, 계약에 의한 설계)
*컴포넌트 설계시 “(협약(Contract))에 의한 설계”를 따를 경우, 해당 명세에서는
(1) 컴포넌트의 오퍼레이션 사용 전에 참이 되어야 할 선행조건
(2) 사용 후 만족되어야 할 결과조건
(3) 오퍼레이션이 실행되는 동안 항상 만족되어야 할 불변조건 등이 포함되어야 한다.

*실시간 소프트웨어 설계 시 고려해야 할 사항이 아닌 것은?*
- 인터럽트와 문맥 교환의 표현
- 태스크들 간의 통신과 동기화
- 타이밍 제약의 표현  
~~동기적인 프로세싱 => 비동기적 프로세싱~~
